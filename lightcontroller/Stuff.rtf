{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf390
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red63\green110\blue116;\red92\green38\blue153;\red46\green13\blue110;
\red28\green0\blue207;\red170\green13\blue145;\red0\green116\blue0;\red196\green26\blue22;\red100\green56\blue32;
}
\paperw12240\paperh15840\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 \
\
To message with buttons \
\
   \cf2 _redButton\cf0 .\cf3 layer\cf0 .\cf3 borderColor\cf0  = [\cf3 UIColor\cf0  \cf4 blackColor\cf0 ].\cf3 CGColor\cf0 ;\
    \cf2 _redButton\cf0 .\cf3 layer\cf0 .\cf3 borderWidth\cf0  = \cf5 1.5\cf0 ;\
    \cf2 _redButton\cf0 .\cf3 tag\cf0  = \cf5 1\cf0  ;\
    [\cf2 _redButton\cf0  \cf4 addTarget\cf0 :\cf6 self\cf0  \cf4 action\cf0 :\cf6 @selector\cf0 (redColor:) \cf4 forControlEvents\cf0 :\cf4 UIControlEventTouchUpInside\cf0 ];\
    \
    \cf2 _greenButton\cf0 .\cf3 layer\cf0 .\cf3 borderColor\cf0  = [\cf3 UIColor\cf0  \cf4 blackColor\cf0 ].\cf3 CGColor\cf0 ;\
    \cf2 _greenButton\cf0 .\cf3 layer\cf0 .\cf3 borderWidth\cf0  = \cf5 1.5\cf0 ;\
    \cf2 _greenButton\cf0 .\cf3 tag\cf0  = \cf5 2\cf0  ;\
    [\cf2 _greenButton\cf0  \cf4 addTarget\cf0 :\cf6 self\cf0  \cf4 action\cf0 :\cf6 @selector\cf0 (greenColor:) \cf4 forControlEvents\cf0 :\cf4 UIControlEventTouchUpInside\cf0 ];\
    \
    \
\cf7 //    _blueButton.layer.borderColor = [UIColor blackColor].CGColor;\cf0 \
\cf7 //    _blueButton.layer.borderWidth = 1.5;\cf0 \
\cf7 //    _blueButton.tag = 2 ;\cf0 \
\cf7 //    [_blueButton addTarget:self action:@selector(greenColor:) forControlEvents:UIControlEventTouchUpInside];\cf0 \
\cf7 //\
\
\
\cf0 - (\cf6 void\cf0 )doHighlight:(\cf3 UIButton\cf0 *)b\
\{\
    [b \cf4 setHighlighted\cf0 :\cf6 YES\cf0 ];\
\}\cf7 \
\cf6 \
\cf0 - (\cf6 void\cf0 )redColor:(\cf2 SSColorSetting\cf0  *)colorSetting\
\{\
    \cf7 //_colorSetting.\cf0 \
\}\
\
    \cf3 UIView\cf0 * _redView;\
    \cf3 UIView\cf0 * _greenView;\
    \cf3 UIView\cf0 * _blueView;\
    \cf3 UIView\cf0 * _yellowView;\
\
    \
\cf7 //    _colorSetting = [[SSColorSetting alloc] init];\cf0 \
\cf7 //    \cf0 \
\cf7 //    [_colorSetting setRedAmount:255];\cf0 \
\cf7 //    [_colorSetting setGreenAmount:255];\cf0 \
\cf7 //    [_colorSetting setBlueAmount:255];\
\
\cf0 \
\cf6 \
\cf7 //\cf0 \
\cf7 //- (IBAction)changeColor:(SSColorSetting*)sender\cf0 \
\cf7 //\{\cf0 \
\cf7 //    UIButton *buttonClicked = (UIButton *)sender;\cf0 \
\cf7 //    \cf0 \
\cf7 //    if (buttonClicked.tag == 1)\cf0 \
\cf7 //    \{\cf0 \
\cf7 //        _redValue.text = @"255";\cf0 \
\cf7 //        _greenValue.text = @"0";\cf0 \
\cf7 //        _blueValue.text = @"0";\cf0 \
\cf7 //    \}\cf0 \
\cf7 //    \cf0 \
\cf7 //    _redValue.text = [NSString stringWithFormat:@"%i", buttonClicked.tag];\cf0 \
\cf7 //    \cf0 \
\cf7 //    [self performSelector:@selector(doHighlight:) withObject:sender afterDelay:0];\cf0 \
\cf7 //    \cf0 \
\cf7 //\}\cf6 \
static\cf0  \cf3 OSStatus\cf0 	AudioUnitRenderCallback (\cf6 void\cf0  *inRefCon,\
                                         AudioUnitRenderActionFlags *ioActionFlags,\
                                         \cf6 const\cf0  AudioTimeStamp *inTimeStamp,\
                                         \cf3 UInt32\cf0  inBusNumber,\
                                         \cf3 UInt32\cf0  inNumberFrames,\
                                         AudioBufferList *ioData) \{\
    \
    \cf3 OSStatus\cf0  err = AudioUnitRender(audioUnitWrapper->audioUnit, ioActionFlags, inTimeStamp, \cf5 1\cf0 , inNumberFrames, ioData);\
    \
    \cf6 if\cf0 (err != \cf5 0\cf0 ) \cf4 NSLog\cf0 (\cf8 @"AudioUnitRender status is %d"\cf0 , err);\
    \cf7 // These values should be in a more conventional location for a bunch of preprocessor defines in your real code\cf0 \
\pard\tx529\pardeftab529\pardirnatural
\cf9 #define DBOFFSET -\cf5 74.0\cf9 \
\pard\tx529\pardeftab529\pardirnatural
\cf0     \cf7 // DBOFFSET is An offset that will be used to normalize the decibels to a maximum of zero.\cf0 \
    \cf7 // This is an estimate, you can do your own or construct an experiment to find the right value\cf0 \
\pard\tx529\pardeftab529\pardirnatural
\cf9 #define LOWPASSFILTERTIMESLICE \cf5 .001\cf9 \
\pard\tx529\pardeftab529\pardirnatural
\cf0     \cf7 // LOWPASSFILTERTIMESLICE is part of the low pass filter and should be a small positive value\cf0 \
    \
    \cf3 SInt16\cf0 * samples = (SInt16*)(ioData->mBuffers[\cf5 0\cf0 ].mData); \cf7 // Step 1: get an array of your samples that you can loop through. Each sample contains the amplitude.\cf0 \
    \
    \cf3 Float32\cf0  decibels = \cf9 DBOFFSET\cf0 ; \cf7 // When we have no signal we'll leave this on the lowest setting\cf0 \
    \cf3 Float32\cf0  currentFilteredValueOfSampleAmplitude, previousFilteredValueOfSampleAmplitude; \cf7 // We'll need these in the low-pass filter\cf0 \
    \cf3 Float32\cf0  peakValue = \cf9 DBOFFSET\cf0 ; \cf7 // We'll end up storing the peak value here\cf0 \
    \
    \cf6 for\cf0  (\cf6 int\cf0  i=\cf5 0\cf0 ; i < inNumberFrames; i++) \{\
        \
        \cf3 Float32\cf0  absoluteValueOfSampleAmplitude = \cf4 abs\cf0 (samples[i]); \cf7 //Step 2: for each sample, get its amplitude's absolute value.\cf0 \
        \
        \cf7 // Step 3: for each sample's absolute value, run it through a simple low-pass filter\cf0 \
        \cf7 // Begin low-pass filter\cf0 \
        currentFilteredValueOfSampleAmplitude = \cf9 LOWPASSFILTERTIMESLICE\cf0  * absoluteValueOfSampleAmplitude + (\cf5 1.0\cf0  - \cf9 LOWPASSFILTERTIMESLICE\cf0 ) * previousFilteredValueOfSampleAmplitude;\
        previousFilteredValueOfSampleAmplitude = currentFilteredValueOfSampleAmplitude;\
        \cf3 Float32\cf0  amplitudeToConvertToDB = currentFilteredValueOfSampleAmplitude;\
        \cf7 // End low-pass filter\cf0 \
        \
        \cf3 Float32\cf0  sampleDB = \cf5 20.0\cf0 *\cf4 log10\cf0 (amplitudeToConvertToDB) + \cf9 DBOFFSET\cf0 ;\
        \cf7 // Step 4: for each sample's filtered absolute value, convert it into decibels\cf0 \
        \cf7 // Step 5: for each sample's filtered absolute value in decibels, add an offset value that normalizes the clipping point of the device to zero.\cf0 \
        \
        \cf6 if\cf0 ((sampleDB == sampleDB) && (sampleDB != -\cf9 DBL_MAX\cf0 )) \{ \cf7 // if it's a rational number and isn't infinite\cf0 \
            \
            \cf6 if\cf0 (sampleDB > peakValue) peakValue = sampleDB; \cf7 // Step 6: keep the highest value you find.\cf0 \
            decibels = peakValue; \cf7 // final value\cf0 \
        \}\
    \}\
    \
    \cf4 NSLog\cf0 (\cf8 @"decibel level is %f"\cf0 , decibels);\
    \
    \cf6 for\cf0  (\cf3 UInt32\cf0  i=\cf5 0\cf0 ; i < ioData->mNumberBuffers; i++) \{ \cf7 // This is only if you need to silence the output of the audio unit\cf0 \
        \cf9 memset\cf0 (ioData->mBuffers[i].mData, \cf5 0\cf0 , ioData->mBuffers[i].mDataByteSize); \cf7 // Delete if you need audio output as well as input\cf0 \
    \}\
    \
    \cf6 return\cf0  err;\
\}\
\}}